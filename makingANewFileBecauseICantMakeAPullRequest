import javax.swing.JFrame;
import javax.imageio.ImageIO;
import javax.swing.ButtonGroup;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JPanel;
import java.awt.event.ActionListener;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.awt.event.ActionEvent;
import javax.swing.SwingConstants;
import javax.swing.JRadioButton;
import javax.swing.JTextField;
import java.awt.Font;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import java.awt.GridLayout;

public class HangmanGui extends JFrame {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private JTextField wordInProgress;
	private JLabel gallows;
	private JLabel livesLeft;
	private JLabel currentChar;// empty initially, latest keystroke
	private String ourCopyOfSecretWord = "";
	private JComponent[] keyButtons;
	private JRadioButton onePlayerButton = new JRadioButton("1 player", true);
	private JRadioButton twoPlayerButton = new JRadioButton("2 players", false);
	private static final String keys = "qwertyuiopasdfghjkl-zxcvbnm";
	private boolean newGame = false;
	
	public char getNextChar() {
		char temp = ' ';
		if (currentChar.getText().length() > 0) {
			temp = currentChar.getText().charAt(0);
			int i = keys.indexOf(temp);
			if (i != -1) {
				keyButtons[i].setEnabled(false);
			}
		}
		currentChar.setText("");
		return temp;
	}

	public void youWin() {
		JOptionPane.showMessageDialog(this, "You guessed the word!\n" + "Nice win.");
	}

	public void youLose(String word) {
		JOptionPane.showMessageDialog(this,
				"Game over you suck.\nThe correct word was " + word + " how did you not guess that?");
	}

	public int getNumPlayers() {
		if (twoPlayerButton.isSelected()) {
			return 2;
		} else {
			return 1;
		}
	}

	private void unlockKeys() {
		// idea, maybe never unlock the label at the end of the second row?
		for (int i = 0; i < keyButtons.length; i++) {
			keyButtons[i].setEnabled(true);
		}
	}
	
	private void lockKeys() {
		for (int i = 0; i < keyButtons.length; i++) {
			keyButtons[i].setEnabled(false);
		}
	}
	
	private void initDisplay(int totalLives, String newSecretWord) {
		// reset for new game, possibly the first game, clear out any prior info or
		// settings
		currentChar.setText("");// no letters guessed yet
		showLivesLeft(totalLives);
		char[] blanks = new char[newSecretWord.length()];
		for (int i = 0; i < newSecretWord.length(); i++) {
			blanks[i] = '_';
		}
		updateWordInProgress(blanks);
		unlockKeys();
	}

	public void initGameGui(int totalLives, String newSecretWord) {
		// init graphics and all member variables
		initDisplay(totalLives, newSecretWord);
		setOurCopyOfSecretWord(newSecretWord);
	}

	/**
	 * Create the frame.
	 */
	public HangmanGui(int totalLives, String newSecretWord) {
		setBounds(100, 100, 1600, 1000);
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setTitle("AP CS Hangman");
		getContentPane().setLayout(new GridLayout(1, 1, 0, 0));// 1 by 1 grid says as large as possible

		JPanel panel = new JPanel();
		panel.setLayout(new GridLayout(0, 10));//10 columns, as many rows as needed
		getContentPane().add(panel);

		wordInProgress = new JTextField();
		wordInProgress.setFont(new Font("SansSerif", Font.PLAIN, 12));
		panel.add(wordInProgress);
		wordInProgress.setColumns(15);// length of longest word? May need to be higher, but would want wider box

		gallows = new JLabel("");
		gallows.setHorizontalAlignment(SwingConstants.CENTER);
		panel.add(gallows);

		JLabel livesLeftLabel = new JLabel("Lives left:");
		livesLeftLabel.setHorizontalAlignment(SwingConstants.CENTER);
		panel.add(livesLeftLabel);

		livesLeft = new JLabel("");
		livesLeft.setHorizontalAlignment(SwingConstants.CENTER);
		panel.add(livesLeft);

		ButtonGroup numPlayers = new ButtonGroup();
		numPlayers.add(onePlayerButton);
		numPlayers.add(twoPlayerButton);

		JLabel label = new JLabel("<html><center>" + "Select" + "<br>" + "number of players" + "</center></html>");
		panel.add(label);
		panel.add(onePlayerButton);
		panel.add(twoPlayerButton);

		JButton newGameButton = new JButton("<html><center>" + "Start" + "<br>" + "new game" + "</center></html>");
		panel.add(newGameButton);
		newGameButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				newGame = true;
				System.out.println("New Game button was pressed");// TODO: remove once done debugging
				// no need to unlockKeys, handled in call to initDisplay via initGameGui
				unlockKeys();// but for now, before "new game" works, it blocks the second game
				// TODO Moshe, add logic to let Hangman know to start new game, and maybe in the meantime stop any action on current game (disable all keys?)
			}
		});

		JButton giveUpButton = new JButton("I give up");
		panel.add(giveUpButton);
		giveUpButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				System.out.println("I give up button was pressed");// TODO: remove once done debugging
				youLose(getOurCopyOfSecretWord());
				lockKeys();
			}
		});
		

		JButton exitButton = new JButton("Exit");
		exitButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				System.exit(0);
			}
		});
		panel.add(exitButton);

		keyButtons = new JComponent[keys.length()];
		int nextButtonIndex = 0;
		for (int i = 0; i < keys.length(); i++) {
			boolean fakeButton = (keys.charAt(i) == '-');
			if (!fakeButton) {
				keyButtons[nextButtonIndex] = new JButton(keys.substring(i, i + 1));
				keyButtons[nextButtonIndex].setEnabled(false);// not enabled until all there,tries to avoid lost first keystroke
				((JButton) keyButtons[nextButtonIndex]).setActionCommand(keys.substring(i, i + 1));
				((JButton) keyButtons[nextButtonIndex]).addActionListener(new ActionListener() {
					public void actionPerformed(ActionEvent e) {
						String temp = e.getActionCommand().substring(0, 1);
						String s = currentChar.getText();
						if (!(s.length() > 0 && Character.isAlphabetic(s.charAt(0)))) {
							currentChar.setText(temp);
						}
					}
				});
			} else {
				keyButtons[nextButtonIndex] = new JLabel("");
				keyButtons[nextButtonIndex].setEnabled(false);//initially not enabled, probably fine to leave it that way, but it's a label so no big deal either way
			}
			panel.add(keyButtons[nextButtonIndex]);
			nextButtonIndex++;
		}
		currentChar = new JLabel("");
		panel.add(currentChar);
		initGameGui(totalLives, newSecretWord);

		// calling program should setVisible(true)

	}

	public void updateWordInProgress(char[] wordWithUnderscores) {
		String result = "";
		boolean first = true;
		for (int i = 0; i < wordWithUnderscores.length; i++) {
			if (!first) {
				result += ' ';
			} else {
				first = false;
			}
			result += wordWithUnderscores[i];
		}
		wordInProgress.setText(result);
	}

	public void showLivesLeft(int numLivesLeft) {
		BufferedImage img = null;
		// TODO Elie choose image based on num lives left
		try {
			img = ImageIO.read(new URL("https://upload.wikimedia.org/wikipedia/commons/8/8b/Hangman-0.png"));
		} catch (MalformedURLException e) {
			System.out.println("Error: bad URL requested");
			System.out.println(e.getMessage());
			e.printStackTrace();
		} catch (IOException e) {
			System.out.println("Error: could not open URL");
			System.out.println(e.getMessage());
			e.printStackTrace();
		}
		ImageIcon icon = null;
		if (!(img == null)) {
			icon = new ImageIcon(img);
		}
		if (!(icon == null)) {
			gallows.setIcon(icon);
		}
		livesLeft.setText("" + numLivesLeft);
	}

	public String getOurCopyOfSecretWord() {
		return ourCopyOfSecretWord;
	}

	public void setOurCopyOfSecretWord(String ourCopyOfSecretWord) {
		this.ourCopyOfSecretWord = ourCopyOfSecretWord;
	}

}






public class HangmanGame {
	//TODO Isaac make these private, creating getters and setters if needed
	private String word;
	private char[] letters; 
	public int wordLength; // Length of word
	public int lives; // # Of lives
	private char[] progress; // Char array of current progress
	private boolean gameOver = false; // boolean of if game is over

	public String getWord() {
		return word;
	}
	
	// Gets random word from list
	public String randomWord() {
		String[] arr = "abolish abridge abstract acclaim accommodate accord adamant advent adversary adversity aesthetic affiliation affirmation affliction aftermath aggravation ambidextrous ambiguous anecdote anguish animated annihilate anonymous apprehensive apprentice aptitude arbitrary arid artifact aspiration assent assertive audacious augment auxiliary avert belligerent benevolent benign bestow bewilder boisterous breach brevity calligraphy cavernous chaotic charisma choreography chronicle chronological circumstantial clientele coalition coerce collaborate collateral colossal commandeer commemorate communal competent concede concentric concise concurrent condemnation condole conglomerate conjecture conscientious consensus constrain contemplate contemporary contrary convene conventional convergent cordial cornucopia credible cynical decipher deficit denounce deprivation derivative designation desolate despicable deterrent deviate dilemma dire discern discrepancy disentangle dismantle dispel disposition dissension distortion divergent diversion dominion dormant dreary dubious eccentric eclipse ecstatic egotistical eloquent embark emphatic encompass eradicate erratic excise exclusion excruciating excursion exemplify expansive facilitate fanaticism fidelity flaunt fluctuate formative formulate fortification fossilized frivolous fruitless futile generic genre gingerly gratification gullible harmonious havoc hindrance homage homogeneous hypocritical hypothetical illustrious impediment impending impenetrable imperative implicit imposition impoverished improvise impulsive inanimate inaugural incarcerate incompatible inconceivable inconclusive inconsequential indispensable induce ineffectual inference infiltrate ingenuity ingrained inherent inhibit initiate innovation instigate integral interim intricate introvert irrelevant jargon jeopardy judicious kinetic laborious lattice lavish longevity luminous luxuriant malice malignant mediocre melancholy memorandum metaphor metropolitan moderation monotonous monumental morale naive nocturnal norm notorious novice nurture objective obliterate ominous omnipotent omniscient parable paradox paramount paraphrase patronize perennial perilous periphery pervasive piety placid plight porous posterity potency preamble predecessor predicament predominant procrastinate procure prophetic protocol proximity purge quarantine ransack ratification rationale ravage ravenous rectify referendum refrain refurbish regime rehabilitate reimburse relinquish reminiscent remnant renovate repercussion replenish repulsive requisite resolve retaliate retort reversion rhetoric rubble rustic sabotage saga sanction satire seasoned secular sedentary senile serene sinister skeptic sovereign spatial squander stagnant stature statutory stereotype strife stupendous subdue subterranean subtle subversive succumb superficial superlative supplement surge susceptible synthesis temperance tenacious tentative terrestrial torrential tranquil traverse trifle trivial turmoil unanimous undermine unison unprecedented unquenchable unrestrained unsightly unsurpassed vengeful versatile viable vibrant vicious vile vintage vogue wary wholesome"
				.split(" ");

		int wordIndex = (int) (arr.length * Math.random());
		return arr[wordIndex];
	}

	// Sets up hangman game
	HangmanGame(HangmanGui hangmanGui, int startLives) {
		lives = startLives;
		if (hangmanGui.getNumPlayers() == 2) {
			word = "getwordfrompopupbox";//TODO Elie add code for word input via JOptionPane.showInputDialog
			}
		else {
			word = randomWord();
		}
		letters = word.toCharArray(); // Splits word to array of chars
		wordLength = word.length(); // Length of word
		
		progress = createBlanks();
		hangmanGui.updateWordInProgress(progress);
		hangmanGui.showLivesLeft(lives);
	}

	// Creates char array of blanks the length of word
	public char[] createBlanks() {
		char[] blanks = new char[word.length()];
		for (int i = 0; word.length() > i; i++) {
			blanks[i] = '_';
		}
		return blanks;
	}


	// Check input
	public void check(char gLetter, HangmanGui hangmanGui) {
		// Check if letter is part of the word
		boolean notDone = true;
		for (int i = 0; word.length() > i; i++) {
			if (gLetter == letters[i]) {
				progress[i] = gLetter;
				notDone = false;// they guessed something right, so we might be done
			}
		}
		hangmanGui.updateWordInProgress(progress);
		// Check if game over in method complete()
		if (notDone) {
			lives -= 1;
			hangmanGui.showLivesLeft(lives);
		}
	}

	// Check amount of remaining blanks
	public int checkBlanks() {
		int blanksLeft = 0;
		for (int i = 0; word.length() > i; i++) {
			if ('_' == progress[i]) {
				blanksLeft += 1;
			}
		}
		return blanksLeft;
	}

	// Check why/if game over
	public void complete(HangmanGui hangmanGui) {
		if (lives == 0) {
			hangmanGui.youLose(word);
			setGameOver(true);
		} else if (checkBlanks() == 0) {
			hangmanGui.youWin();
			setGameOver(true);
		}
	}


	// Check if letter in word
	public void isGuessed(char g, HangmanGui hangmanGui) {
			check(g, hangmanGui);
	}

	public boolean isGameOver() {
		return gameOver;
	}

	public void setGameOver(boolean gameOver) {
		this.gameOver = gameOver;
	}

	public boolean getNewGame(){
		return newGame;
	}

	public boolean setNewGame(boolean newGame){
		this.newGame = newGame;
	  }
}






public class Hangman {
	static final int livesPerGame = 5;

	public static void main(String[] args) {
		HangmanGui frame = null;
		try {
			frame = new HangmanGui(livesPerGame, "");
			frame.setVisible(true);
		} catch (Exception e) {
			System.out.println("Error setting up GUI "+ e.getMessage());
			e.printStackTrace();
		}
		char letter;

		do {

			//TODO, Moshe, wait here until they say New Game (maybe confirm or give up first)
			
			HangmanGame hangmanGame = new HangmanGame(frame, livesPerGame); // Sets up hangman
			frame.initGameGui(livesPerGame, hangmanGame.getWord());

			hangmanGame.setNewGame(false);
			if(!frame.getNewGame()){
				continue;
			 }
			
			   //TODO maybe make playOneGame a separate method
			while (true) {
				letter = frame.getNextChar();
				if (!Character.isLetter(letter)) {
					continue;
				}
				hangmanGame.isGuessed(letter, frame); // Check input
				hangmanGame.complete(frame); // Check if/why game over
				if (hangmanGame.isGameOver() || frame.getNewGame()) {
					break; // if gameover stop game
				}
			}
		} while (true); // Only close when they say quit or close 
	}

}
